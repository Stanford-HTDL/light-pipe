<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>light_pipe.mercantile API documentation</title>
<meta name="description" content="From: https://github.com/mapbox/mercantile/blob/fe3762d14001ca400caf7462f59433b906fc25bd/mercantile/__init__.py
Credit: Mapbox
Original License: â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>light_pipe.mercantile</code></h1>
</header>
<section id="section-intro">
<p>From: <a href="https://github.com/mapbox/mercantile/blob/fe3762d14001ca400caf7462f59433b906fc25bd/mercantile/__init__.py">https://github.com/mapbox/mercantile/blob/fe3762d14001ca400caf7462f59433b906fc25bd/mercantile/__init__.py</a>
Credit: Mapbox
Original License: BSD-3-Clause
License Text:</p>
<p>Copyright 2021, Mapbox</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<pre><code>* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of the copyright holder nor the names of
  its contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.
</code></pre>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
From: https://github.com/mapbox/mercantile/blob/fe3762d14001ca400caf7462f59433b906fc25bd/mercantile/__init__.py
Credit: Mapbox
Original License: BSD-3-Clause
License Text:

Copyright 2021, Mapbox

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of
      its contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
&#34;&#34;&#34;

&#34;&#34;&#34;Web mercator XYZ tile utilities&#34;&#34;&#34;

from collections import namedtuple
from functools import reduce
import math
import sys
import warnings
import operator

if sys.version_info &lt; (3,):
    warnings.warn(
        &#34;Python versions &lt; 3 will not be supported by mercantile 2.0.&#34;,
        UserWarning,
    )
    from collections import Sequence

    def lru_cache(maxsize=None):
        &#34;&#34;&#34;Does nothing. We do not cache for Python &lt; 3.&#34;&#34;&#34;

        def fake_decorator(func):
            return func

        return fake_decorator


else:
    from collections.abc import Sequence
    from functools import lru_cache


__version__ = &#34;1.2.1&#34;

__all__ = [
    &#34;Bbox&#34;,
    &#34;LngLat&#34;,
    &#34;LngLatBbox&#34;,
    &#34;Tile&#34;,
    &#34;bounding_tile&#34;,
    &#34;bounds&#34;,
    &#34;children&#34;,
    &#34;feature&#34;,
    &#34;lnglat&#34;,
    &#34;neighbors&#34;,
    &#34;parent&#34;,
    &#34;quadkey&#34;,
    &#34;quadkey_to_tile&#34;,
    &#34;simplify&#34;,
    &#34;tile&#34;,
    &#34;tiles&#34;,
    &#34;ul&#34;,
    &#34;xy_bounds&#34;,
    &#34;minmax&#34;,
]


R2D = 180 / math.pi
RE = 6378137.0
CE = 2 * math.pi * RE
EPSILON = 1e-14
LL_EPSILON = 1e-11


class Tile(namedtuple(&#34;Tile&#34;, [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;])):
    &#34;&#34;&#34;An XYZ web mercator tile

    Attributes
    ----------
    x, y, z : int
        x and y indexes of the tile and zoom level z.

    &#34;&#34;&#34;

    def __new__(cls, x, y, z):
        &#34;&#34;&#34;A new instance&#34;&#34;&#34;
        lo, hi = minmax(z)
        if not lo &lt;= x &lt;= hi or not lo &lt;= y &lt;= hi:
            warnings.warn(
                &#34;Mercantile 2.0 will require tile x and y to be within the range (0, 2 ** zoom)&#34;,
                FutureWarning,
            )
        return tuple.__new__(cls, [x, y, z])


LngLat = namedtuple(&#34;LngLat&#34;, [&#34;lng&#34;, &#34;lat&#34;])
&#34;&#34;&#34;A longitude and latitude pair

Attributes
----------
lng, lat : float
    Longitude and latitude in decimal degrees east or north.
&#34;&#34;&#34;


LngLatBbox = namedtuple(&#34;LngLatBbox&#34;, [&#34;west&#34;, &#34;south&#34;, &#34;east&#34;, &#34;north&#34;])
&#34;&#34;&#34;A geographic bounding box

Attributes
----------
west, south, east, north : float
    Bounding values in decimal degrees.
&#34;&#34;&#34;


Bbox = namedtuple(&#34;Bbox&#34;, [&#34;left&#34;, &#34;bottom&#34;, &#34;right&#34;, &#34;top&#34;])
&#34;&#34;&#34;A web mercator bounding box

Attributes
----------
left, bottom, right, top : float
    Bounding values in meters.
&#34;&#34;&#34;


class MercantileError(Exception):
    &#34;&#34;&#34;Base exception&#34;&#34;&#34;


class InvalidLatitudeError(MercantileError):
    &#34;&#34;&#34;Raised when math errors occur beyond ~85 degrees N or S&#34;&#34;&#34;


class InvalidZoomError(MercantileError):
    &#34;&#34;&#34;Raised when a zoom level is invalid&#34;&#34;&#34;


class ParentTileError(MercantileError):
    &#34;&#34;&#34;Raised when a parent tile cannot be determined&#34;&#34;&#34;


class QuadKeyError(MercantileError):
    &#34;&#34;&#34;Raised when errors occur in computing or parsing quad keys&#34;&#34;&#34;


class TileArgParsingError(MercantileError):
    &#34;&#34;&#34;Raised when errors occur in parsing a function&#39;s tile arg(s)&#34;&#34;&#34;


class TileError(MercantileError):
    &#34;&#34;&#34;Raised when a tile can&#39;t be determined&#34;&#34;&#34;


def _parse_tile_arg(*args):
    &#34;&#34;&#34;parse the *tile arg of module functions

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    Tile

    Raises
    ------
    TileArgParsingError

    &#34;&#34;&#34;
    if len(args) == 1:
        args = args[0]
    if len(args) == 3:
        return Tile(*args)
    else:
        raise TileArgParsingError(
            &#34;the tile argument may have 1 or 3 values. Note that zoom is a keyword-only argument&#34;
        )


def ul(*tile):
    &#34;&#34;&#34;Returns the upper left longitude and latitude of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    LngLat

    Examples
    --------

    &gt;&gt;&gt; ul(Tile(x=0, y=0, z=1))
    LngLat(lng=-180.0, lat=85.0511287798066)

    &gt;&gt;&gt; mercantile.ul(1, 1, 1)
    LngLat(lng=0.0, lat=0.0)

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile
    Z2 = math.pow(2, zoom)
    lon_deg = xtile / Z2 * 360.0 - 180.0
    lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / Z2)))
    lat_deg = math.degrees(lat_rad)
    return LngLat(lon_deg, lat_deg)


def bounds(*tile):
    &#34;&#34;&#34;Returns the bounding box of a tile

    Parameters
    ----------
    tile : Tile or tuple
        May be be either an instance of Tile or 3 ints (X, Y, Z).

    Returns
    -------
    LngLatBbox

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile

    Z2 = math.pow(2, zoom)

    ul_lon_deg = xtile / Z2 * 360.0 - 180.0
    ul_lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / Z2)))
    ul_lat_deg = math.degrees(ul_lat_rad)

    lr_lon_deg = (xtile + 1) / Z2 * 360.0 - 180.0
    lr_lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * (ytile + 1) / Z2)))
    lr_lat_deg = math.degrees(lr_lat_rad)

    return LngLatBbox(ul_lon_deg, lr_lat_deg, lr_lon_deg, ul_lat_deg)


def truncate_lnglat(lng, lat):
    if lng &gt; 180.0:
        lng = 180.0
    elif lng &lt; -180.0:
        lng = -180.0
    if lat &gt; 90.0:
        lat = 90.0
    elif lat &lt; -90.0:
        lat = -90.0
    return lng, lat


def xy(lng, lat, truncate=False):
    &#34;&#34;&#34;Convert longitude and latitude to web mercator x, y

    Parameters
    ----------
    lng, lat : float
        Longitude and latitude in decimal degrees.
    truncate : bool, optional
        Whether to truncate or clip inputs to web mercator limits.

    Returns
    -------
    x, y : float
        y will be inf at the North Pole (lat &gt;= 90) and -inf at the
        South Pole (lat &lt;= -90).

    &#34;&#34;&#34;
    if truncate:
        lng, lat = truncate_lnglat(lng, lat)

    x = RE * math.radians(lng)

    if lat &lt;= -90:
        y = float(&#34;-inf&#34;)
    elif lat &gt;= 90:
        y = float(&#34;inf&#34;)
    else:
        y = RE * math.log(math.tan((math.pi * 0.25) + (0.5 * math.radians(lat))))

    return x, y


def lnglat(x, y, truncate=False):
    &#34;&#34;&#34;Convert web mercator x, y to longitude and latitude

    Parameters
    ----------
    x, y : float
        web mercator coordinates in meters.
    truncate : bool, optional
        Whether to truncate or clip inputs to web mercator limits.

    Returns
    -------
    LngLat

    &#34;&#34;&#34;
    lng, lat = (
        x * R2D / RE,
        ((math.pi * 0.5) - 2.0 * math.atan(math.exp(-y / RE))) * R2D,
    )
    if truncate:
        lng, lat = truncate_lnglat(lng, lat)
    return LngLat(lng, lat)


def neighbors(*tile, **kwargs):
    &#34;&#34;&#34;The neighbors of a tile

    The neighbors function makes no guarantees regarding neighbor tile
    ordering.

    The neighbors function returns up to eight neighboring tiles, where
    tiles will be omitted when they are not valid e.g. Tile(-1, -1, z).

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    list

    Examples
    --------
    &gt;&gt;&gt; neighbors(Tile(486, 332, 10))
    [Tile(x=485, y=331, z=10), Tile(x=485, y=332, z=10), Tile(x=485, y=333, z=10), Tile(x=486, y=331, z=10), Tile(x=486, y=333, z=10), Tile(x=487, y=331, z=10), Tile(x=487, y=332, z=10), Tile(x=487, y=333, z=10)]

    &#34;&#34;&#34;
    xtile, ytile, ztile = _parse_tile_arg(*tile)

    tiles = []

    lo, hi = minmax(ztile)

    for i in [-1, 0, 1]:
        for j in [-1, 0, 1]:
            if i == 0 and j == 0:
                continue
            elif xtile + i &lt; 0 or ytile + j &lt; 0:
                continue
            elif xtile + i &gt; hi or ytile + j &gt; hi:
                continue
            tiles.append(Tile(x=xtile + i, y=ytile + j, z=ztile))

    # Make sure to not generate invalid tiles for valid input
    # https://github.com/mapbox/mercantile/issues/122
    def valid(tile):
        validx = 0 &lt;= tile.x &lt;= 2 ** tile.z - 1
        validy = 0 &lt;= tile.y &lt;= 2 ** tile.z - 1
        validz = 0 &lt;= tile.z
        return validx and validy and validz

    tiles = [t for t in tiles if valid(t)]

    return tiles


def xy_bounds(*tile):
    &#34;&#34;&#34;Get the web mercator bounding box of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    Bbox

    Notes
    -----
    Epsilon is subtracted from the right limit and added to the bottom
    limit.

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile

    tile_size = CE / math.pow(2, zoom)

    left = xtile * tile_size - CE / 2
    right = left + tile_size

    top = CE / 2 - ytile * tile_size
    bottom = top - tile_size

    return Bbox(left, bottom, right, top)


def _xy(lng, lat, truncate=False):

    if truncate:
        lng, lat = truncate_lnglat(lng, lat)

    x = lng / 360.0 + 0.5
    sinlat = math.sin(math.radians(lat))

    try:
        y = 0.5 - 0.25 * math.log((1.0 + sinlat) / (1.0 - sinlat)) / math.pi
    except (ValueError, ZeroDivisionError):
        raise InvalidLatitudeError(&#34;Y can not be computed: lat={!r}&#34;.format(lat))
    else:
        return x, y


def tile(lng, lat, zoom, truncate=False):
    &#34;&#34;&#34;Get the tile containing a longitude and latitude

    Parameters
    ----------
    lng, lat : float
        A longitude and latitude pair in decimal degrees.
    zoom : int
        The web mercator zoom level.
    truncate : bool, optional
        Whether or not to truncate inputs to limits of web mercator.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    x, y = _xy(lng, lat, truncate=truncate)
    Z2 = math.pow(2, zoom)

    if x &lt;= 0:
        xtile = 0
    elif x &gt;= 1:
        xtile = int(Z2 - 1)
    else:
        # To address loss of precision in round-tripping between tile
        # and lng/lat, points within EPSILON of the right side of a tile
        # are counted in the next tile over.
        xtile = int(math.floor((x + EPSILON) * Z2))

    if y &lt;= 0:
        ytile = 0
    elif y &gt;= 1:
        ytile = int(Z2 - 1)
    else:
        ytile = int(math.floor((y + EPSILON) * Z2))

    return Tile(xtile, ytile, zoom)


def quadkey(*tile):
    &#34;&#34;&#34;Get the quadkey of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    str

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile
    qk = []
    for z in range(zoom, 0, -1):
        digit = 0
        mask = 1 &lt;&lt; (z - 1)
        if xtile &amp; mask:
            digit += 1
        if ytile &amp; mask:
            digit += 2
        qk.append(str(digit))
    return &#34;&#34;.join(qk)


def quadkey_to_tile(qk):
    &#34;&#34;&#34;Get the tile corresponding to a quadkey

    Parameters
    ----------
    qk : str
        A quadkey string.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    if len(qk) == 0:
        return Tile(0, 0, 0)
    xtile, ytile = 0, 0
    for i, digit in enumerate(reversed(qk)):
        mask = 1 &lt;&lt; i
        if digit == &#34;1&#34;:
            xtile = xtile | mask
        elif digit == &#34;2&#34;:
            ytile = ytile | mask
        elif digit == &#34;3&#34;:
            xtile = xtile | mask
            ytile = ytile | mask
        elif digit != &#34;0&#34;:
            warnings.warn(
                &#34;QuadKeyError will not derive from ValueError in mercantile 2.0.&#34;,
                DeprecationWarning,
            )
            raise QuadKeyError(&#34;Unexpected quadkey digit: %r&#34;, digit)
    return Tile(xtile, ytile, i + 1)


def tiles(west, south, east, north, zooms, truncate=False):
    &#34;&#34;&#34;Get the tiles overlapped by a geographic bounding box

    Parameters
    ----------
    west, south, east, north : sequence of float
        Bounding values in decimal degrees.
    zooms : int or sequence of int
        One or more zoom levels.
    truncate : bool, optional
        Whether or not to truncate inputs to web mercator limits.

    Yields
    ------
    Tile

    Notes
    -----
    A small epsilon is used on the south and east parameters so that this
    function yields exactly one tile when given the bounds of that same tile.

    &#34;&#34;&#34;
    if truncate:
        west, south = truncate_lnglat(west, south)
        east, north = truncate_lnglat(east, north)
    if west &gt; east:
        bbox_west = (-180.0, south, east, north)
        bbox_east = (west, south, 180.0, north)
        bboxes = [bbox_west, bbox_east]
    else:
        bboxes = [(west, south, east, north)]

    for w, s, e, n in bboxes:
        # Clamp bounding values.
        w = max(-180.0, w)
        s = max(-85.051129, s)
        e = min(180.0, e)
        n = min(85.051129, n)

        if not isinstance(zooms, Sequence):
            zooms = [zooms]

        for z in zooms:
            ul_tile = tile(w, n, z)
            lr_tile = tile(e - LL_EPSILON, s + LL_EPSILON, z)

            for i in range(ul_tile.x, lr_tile.x + 1):
                for j in range(ul_tile.y, lr_tile.y + 1):
                    yield Tile(i, j, z)


def parent(*tile, **kwargs):
    &#34;&#34;&#34;Get the parent of a tile

    The parent is the tile of one zoom level lower that contains the
    given &#34;child&#34; tile.

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    zoom : int, optional
        Determines the *zoom* level of the returned parent tile.
        This defaults to one lower than the tile (the immediate parent).

    Returns
    -------
    Tile

    Examples
    --------
    &gt;&gt;&gt; parent(Tile(0, 0, 2))
    Tile(x=0, y=0, z=1)
    &gt;&gt;&gt; parent(Tile(0, 0, 2), zoom=0)
    Tile(x=0, y=0, z=0)

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    x, y, z = tile

    if z == 0:
        return None

    # zoom is a keyword-only argument.
    zoom = kwargs.get(&#34;zoom&#34;, None)

    if zoom is not None and (z &lt;= zoom or zoom != int(zoom)):
        raise InvalidZoomError(
            &#34;zoom must be an integer and less than that of the input tile&#34;
        )

    if x != int(x) or y != int(y) or z != int(z):
        raise ParentTileError(&#34;the parent of a non-integer tile is undefined&#34;)

    target_zoom = z - 1 if zoom is None else zoom

    # Algorithm heavily inspired by https://github.com/mapbox/tilebelt.
    return_tile = tile
    while return_tile[2] &gt; target_zoom:
        xtile, ytile, ztile = return_tile
        if xtile % 2 == 0 and ytile % 2 == 0:
            return_tile = Tile(xtile // 2, ytile // 2, ztile - 1)
        elif xtile % 2 == 0:
            return_tile = Tile(xtile // 2, (ytile - 1) // 2, ztile - 1)
        elif not xtile % 2 == 0 and ytile % 2 == 0:
            return_tile = Tile((xtile - 1) // 2, ytile // 2, ztile - 1)
        else:
            return_tile = Tile((xtile - 1) // 2, (ytile - 1) // 2, ztile - 1)
    return return_tile


def children(*tile, **kwargs):
    &#34;&#34;&#34;Get the children of a tile

    The children are ordered: top-left, top-right, bottom-right, bottom-left.

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    zoom : int, optional
        Returns all children at zoom *zoom*, in depth-first clockwise
        winding order.  If unspecified, returns the immediate (i.e. zoom
        + 1) children of the tile.

    Returns
    -------
    list

    Raises
    ------
    InvalidZoomError
        If the zoom level is not an integer greater than the zoom level
        of the input tile.

    Examples
    --------
    &gt;&gt;&gt; children(Tile(0, 0, 0))
    [Tile(x=0, y=0, z=1), Tile(x=0, y=1, z=1), Tile(x=1, y=0, z=1), Tile(x=1, y=1, z=1)]
    &gt;&gt;&gt; children(Tile(0, 0, 0), zoom=2)
    [Tile(x=0, y=0, z=2), Tile(x=0, y=1, z=2), Tile(x=0, y=2, z=2), Tile(x=0, y=3, z=2), ...]

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)

    # zoom is a keyword-only argument.
    zoom = kwargs.get(&#34;zoom&#34;, None)

    xtile, ytile, ztile = tile

    if zoom is not None and (ztile &gt; zoom or zoom != int(zoom)):
        raise InvalidZoomError(
            &#34;zoom must be an integer and greater than that of the input tile&#34;
        )

    target_zoom = zoom if zoom is not None else ztile + 1

    tiles = [tile]

    while tiles[0][2] &lt; target_zoom:
        xtile, ytile, ztile = tiles.pop(0)
        tiles += [
            Tile(xtile * 2, ytile * 2, ztile + 1),
            Tile(xtile * 2 + 1, ytile * 2, ztile + 1),
            Tile(xtile * 2 + 1, ytile * 2 + 1, ztile + 1),
            Tile(xtile * 2, ytile * 2 + 1, ztile + 1),
        ]

    return tiles


def simplify(tiles):
    &#34;&#34;&#34;Reduces the size of the tileset as much as possible by merging leaves into parents.

    Parameters
    ----------
    tiles : Sequence of tiles to merge.

    Returns
    -------
    list

    &#34;&#34;&#34;

    def merge(merge_set):
        &#34;&#34;&#34;Checks to see if there are 4 tiles in merge_set which can be merged.
        If there are, this merges them.
        This returns a list of tiles, as well as a boolean indicating if any were merged.
        By repeatedly applying merge, a tileset can be simplified.
        &#34;&#34;&#34;
        upwards_merge = {}
        for tile in merge_set:
            tile_parent = parent(tile)
            if tile_parent not in upwards_merge:
                upwards_merge[tile_parent] = set()
            upwards_merge[tile_parent] |= {tile}
        current_tileset = []
        changed = False
        for supertile, children in upwards_merge.items():
            if len(children) == 4:
                current_tileset += [supertile]
                changed = True
            else:
                current_tileset += list(children)
        return current_tileset, changed

    # Check to see if a tile and its parent both already exist.
    # Ensure that tiles are sorted by zoom so parents are encountered first.
    # If so, discard the child (it&#39;s covered in the parent)
    root_set = set()
    for tile in sorted(tiles, key=operator.itemgetter(2)):
        x, y, z = tile
        is_new_tile = True
        for supertile in (parent(tile, zoom=i) for i in range(z)):
            if supertile in root_set:
                is_new_tile = False
                continue
        if is_new_tile:
            root_set |= {tile}

    # Repeatedly run merge until no further simplification is possible.
    is_merging = True
    while is_merging:
        root_set, is_merging = merge(root_set)
    return root_set


def rshift(val, n):
    return (val % 0x100000000) &gt;&gt; n


def bounding_tile(*bbox, **kwds):
    &#34;&#34;&#34;Get the smallest tile containing a geographic bounding box

    NB: when the bbox spans lines of lng 0 or lat 0, the bounding tile
    will be Tile(x=0, y=0, z=0).

    Parameters
    ----------
    bbox : sequence of float
        west, south, east, north bounding values in decimal degrees.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    if len(bbox) == 2:
        bbox += bbox

    w, s, e, n = bbox

    truncate = bool(kwds.get(&#34;truncate&#34;))

    if truncate:
        w, s = truncate_lnglat(w, s)
        e, n = truncate_lnglat(e, n)

    e = e - LL_EPSILON
    s = s + LL_EPSILON

    try:
        tmin = tile(w, n, 32)
        tmax = tile(e, s, 32)
    except InvalidLatitudeError:
        return Tile(0, 0, 0)

    cell = tmin[:2] + tmax[:2]
    z = _getBboxZoom(*cell)

    if z == 0:
        return Tile(0, 0, 0)

    x = rshift(cell[0], (32 - z))
    y = rshift(cell[1], (32 - z))

    return Tile(x, y, z)


def _getBboxZoom(*bbox):
    MAX_ZOOM = 28
    for z in range(0, MAX_ZOOM):
        mask = 1 &lt;&lt; (32 - (z + 1))
        if (bbox[0] &amp; mask) != (bbox[2] &amp; mask) or (bbox[1] &amp; mask) != (bbox[3] &amp; mask):
            return z
    return MAX_ZOOM


def feature(
    tile, fid=None, props=None, projected=&#34;geographic&#34;, buffer=None, precision=None
):
    &#34;&#34;&#34;Get the GeoJSON feature corresponding to a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    fid : str, optional
        A feature id.
    props : dict, optional
        Optional extra feature properties.
    projected : str, optional
        Non-standard web mercator GeoJSON can be created by passing
        &#39;mercator&#39;.
    buffer : float, optional
        Optional buffer distance for the GeoJSON polygon.
    precision : int, optional
        GeoJSON coordinates will be truncated to this number of decimal
        places.

    Returns
    -------
    dict

    &#34;&#34;&#34;
    west, south, east, north = bounds(tile)

    if projected == &#34;mercator&#34;:
        west, south = xy(west, south, truncate=False)
        east, north = xy(east, north, truncate=False)

    if buffer:
        west -= buffer
        south -= buffer
        east += buffer
        north += buffer

    if precision and precision &gt;= 0:
        west, south, east, north = (
            round(v, precision) for v in (west, south, east, north)
        )

    bbox = [min(west, east), min(south, north), max(west, east), max(south, north)]
    geom = {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
            [[west, south], [west, north], [east, north], [east, south], [west, south]]
        ],
    }

    xyz = str(tile)
    feat = {
        &#34;type&#34;: &#34;Feature&#34;,
        &#34;bbox&#34;: bbox,
        &#34;id&#34;: xyz,
        &#34;geometry&#34;: geom,
        &#34;properties&#34;: {&#34;title&#34;: &#34;XYZ tile %s&#34; % xyz},
    }

    if props:
        feat[&#34;properties&#34;].update(props)

    if fid is not None:
        feat[&#34;id&#34;] = fid

    return feat


def _coords(obj):
    &#34;&#34;&#34;All coordinate tuples from a geometry or feature or collection

    Yields
    ------
    lng : float
        Longitude
    lat : float
        Latitude

    &#34;&#34;&#34;
    if isinstance(obj, (tuple, list)):
        coordinates = obj
    elif &#34;features&#34; in obj:
        coordinates = [feat[&#34;geometry&#34;][&#34;coordinates&#34;] for feat in obj[&#34;features&#34;]]
    elif &#34;geometry&#34; in obj:
        coordinates = obj[&#34;geometry&#34;][&#34;coordinates&#34;]
    else:
        coordinates = obj.get(&#34;coordinates&#34;, obj)

    for e in coordinates:
        if isinstance(e, (float, int)):
            yield tuple(coordinates)
            break
        else:
            for f in _coords(e):
                yield f[:2]


def geojson_bounds(obj):
    &#34;&#34;&#34;Returns the bounding box of a GeoJSON object

    Parameters
    ----------
    obj : mapping
        A GeoJSON geometry, feature, or feature collection.

    Returns
    -------
    LngLatBbox

    &#34;&#34;&#34;

    def func(bbox, coords):
        w, s, e, n = bbox
        lng, lat = coords
        return min(w, lng), min(s, lat), max(e, lng), max(n, lat)

    w, s, e, n = reduce(func, _coords(obj), (180.0, 90.0, -180.0, -90.0))
    return LngLatBbox(w, s, e, n)


@lru_cache(maxsize=28)
def minmax(zoom):
    &#34;&#34;&#34;Minimum and maximum tile coordinates for a zoom level

    Parameters
    ----------
    zoom : int
        The web mercator zoom level.

    Returns
    -------
    minimum : int
        Minimum tile coordinate (note: always 0).
    maximum : int
        Maximum tile coordinate (2 ** zoom - 1).

    Raises
    ------
    InvalidZoomError
        If zoom level is not a positive integer.

    Examples
    --------
    &gt;&gt;&gt; minmax(1)
    (0, 1)
    &gt;&gt;&gt; minmax(-1)
    Traceback (most recent call last):
    ...
    InvalidZoomError: zoom must be a positive integer

    &#34;&#34;&#34;

    try:
        if int(zoom) != zoom or zoom &lt; 0:
            raise InvalidZoomError(&#34;zoom must be a positive integer&#34;)
    except ValueError:
        raise InvalidZoomError(&#34;zoom must be a positive integer&#34;)

    return (0, 2 ** zoom - 1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="light_pipe.mercantile.bounding_tile"><code class="name flex">
<span>def <span class="ident">bounding_tile</span></span>(<span>*bbox, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the smallest tile containing a geographic bounding box</p>
<p>NB: when the bbox spans lines of lng 0 or lat 0, the bounding tile
will be Tile(x=0, y=0, z=0).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bbox</code></strong> :&ensp;<code>sequence</code> of <code>float</code></dt>
<dd>west, south, east, north bounding values in decimal degrees.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_tile(*bbox, **kwds):
    &#34;&#34;&#34;Get the smallest tile containing a geographic bounding box

    NB: when the bbox spans lines of lng 0 or lat 0, the bounding tile
    will be Tile(x=0, y=0, z=0).

    Parameters
    ----------
    bbox : sequence of float
        west, south, east, north bounding values in decimal degrees.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    if len(bbox) == 2:
        bbox += bbox

    w, s, e, n = bbox

    truncate = bool(kwds.get(&#34;truncate&#34;))

    if truncate:
        w, s = truncate_lnglat(w, s)
        e, n = truncate_lnglat(e, n)

    e = e - LL_EPSILON
    s = s + LL_EPSILON

    try:
        tmin = tile(w, n, 32)
        tmax = tile(e, s, 32)
    except InvalidLatitudeError:
        return Tile(0, 0, 0)

    cell = tmin[:2] + tmax[:2]
    z = _getBboxZoom(*cell)

    if z == 0:
        return Tile(0, 0, 0)

    x = rshift(cell[0], (32 - z))
    y = rshift(cell[1], (32 - z))

    return Tile(x, y, z)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.bounds"><code class="name flex">
<span>def <span class="ident">bounds</span></span>(<span>*tile)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the bounding box of a tile</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>tuple</code></dt>
<dd>May be be either an instance of Tile or 3 ints (X, Y, Z).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.LngLatBbox" href="#light_pipe.mercantile.LngLatBbox">LngLatBbox</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounds(*tile):
    &#34;&#34;&#34;Returns the bounding box of a tile

    Parameters
    ----------
    tile : Tile or tuple
        May be be either an instance of Tile or 3 ints (X, Y, Z).

    Returns
    -------
    LngLatBbox

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile

    Z2 = math.pow(2, zoom)

    ul_lon_deg = xtile / Z2 * 360.0 - 180.0
    ul_lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / Z2)))
    ul_lat_deg = math.degrees(ul_lat_rad)

    lr_lon_deg = (xtile + 1) / Z2 * 360.0 - 180.0
    lr_lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * (ytile + 1) / Z2)))
    lr_lat_deg = math.degrees(lr_lat_rad)

    return LngLatBbox(ul_lon_deg, lr_lat_deg, lr_lon_deg, ul_lat_deg)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>*tile, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the children of a tile</p>
<p>The children are ordered: top-left, top-right, bottom-right, bottom-left.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Returns all children at zoom <em>zoom</em>, in depth-first clockwise
winding order.
If unspecified, returns the immediate (i.e. zoom
+ 1) children of the tile.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidZoomError</code></dt>
<dd>If the zoom level is not an integer greater than the zoom level
of the input tile.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; children(Tile(0, 0, 0))
[Tile(x=0, y=0, z=1), Tile(x=0, y=1, z=1), Tile(x=1, y=0, z=1), Tile(x=1, y=1, z=1)]
&gt;&gt;&gt; children(Tile(0, 0, 0), zoom=2)
[Tile(x=0, y=0, z=2), Tile(x=0, y=1, z=2), Tile(x=0, y=2, z=2), Tile(x=0, y=3, z=2), ...]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(*tile, **kwargs):
    &#34;&#34;&#34;Get the children of a tile

    The children are ordered: top-left, top-right, bottom-right, bottom-left.

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    zoom : int, optional
        Returns all children at zoom *zoom*, in depth-first clockwise
        winding order.  If unspecified, returns the immediate (i.e. zoom
        + 1) children of the tile.

    Returns
    -------
    list

    Raises
    ------
    InvalidZoomError
        If the zoom level is not an integer greater than the zoom level
        of the input tile.

    Examples
    --------
    &gt;&gt;&gt; children(Tile(0, 0, 0))
    [Tile(x=0, y=0, z=1), Tile(x=0, y=1, z=1), Tile(x=1, y=0, z=1), Tile(x=1, y=1, z=1)]
    &gt;&gt;&gt; children(Tile(0, 0, 0), zoom=2)
    [Tile(x=0, y=0, z=2), Tile(x=0, y=1, z=2), Tile(x=0, y=2, z=2), Tile(x=0, y=3, z=2), ...]

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)

    # zoom is a keyword-only argument.
    zoom = kwargs.get(&#34;zoom&#34;, None)

    xtile, ytile, ztile = tile

    if zoom is not None and (ztile &gt; zoom or zoom != int(zoom)):
        raise InvalidZoomError(
            &#34;zoom must be an integer and greater than that of the input tile&#34;
        )

    target_zoom = zoom if zoom is not None else ztile + 1

    tiles = [tile]

    while tiles[0][2] &lt; target_zoom:
        xtile, ytile, ztile = tiles.pop(0)
        tiles += [
            Tile(xtile * 2, ytile * 2, ztile + 1),
            Tile(xtile * 2 + 1, ytile * 2, ztile + 1),
            Tile(xtile * 2 + 1, ytile * 2 + 1, ztile + 1),
            Tile(xtile * 2, ytile * 2 + 1, ztile + 1),
        ]

    return tiles</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.feature"><code class="name flex">
<span>def <span class="ident">feature</span></span>(<span>tile, fid=None, props=None, projected='geographic', buffer=None, precision=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the GeoJSON feature corresponding to a tile</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
<dt><strong><code>fid</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A feature id.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Optional extra feature properties.</dd>
<dt><strong><code>projected</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Non-standard web mercator GeoJSON can be created by passing
'mercator'.</dd>
<dt><strong><code>buffer</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Optional buffer distance for the GeoJSON polygon.</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>GeoJSON coordinates will be truncated to this number of decimal
places.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feature(
    tile, fid=None, props=None, projected=&#34;geographic&#34;, buffer=None, precision=None
):
    &#34;&#34;&#34;Get the GeoJSON feature corresponding to a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    fid : str, optional
        A feature id.
    props : dict, optional
        Optional extra feature properties.
    projected : str, optional
        Non-standard web mercator GeoJSON can be created by passing
        &#39;mercator&#39;.
    buffer : float, optional
        Optional buffer distance for the GeoJSON polygon.
    precision : int, optional
        GeoJSON coordinates will be truncated to this number of decimal
        places.

    Returns
    -------
    dict

    &#34;&#34;&#34;
    west, south, east, north = bounds(tile)

    if projected == &#34;mercator&#34;:
        west, south = xy(west, south, truncate=False)
        east, north = xy(east, north, truncate=False)

    if buffer:
        west -= buffer
        south -= buffer
        east += buffer
        north += buffer

    if precision and precision &gt;= 0:
        west, south, east, north = (
            round(v, precision) for v in (west, south, east, north)
        )

    bbox = [min(west, east), min(south, north), max(west, east), max(south, north)]
    geom = {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
            [[west, south], [west, north], [east, north], [east, south], [west, south]]
        ],
    }

    xyz = str(tile)
    feat = {
        &#34;type&#34;: &#34;Feature&#34;,
        &#34;bbox&#34;: bbox,
        &#34;id&#34;: xyz,
        &#34;geometry&#34;: geom,
        &#34;properties&#34;: {&#34;title&#34;: &#34;XYZ tile %s&#34; % xyz},
    }

    if props:
        feat[&#34;properties&#34;].update(props)

    if fid is not None:
        feat[&#34;id&#34;] = fid

    return feat</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.lnglat"><code class="name flex">
<span>def <span class="ident">lnglat</span></span>(<span>x, y, truncate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert web mercator x, y to longitude and latitude</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>web mercator coordinates in meters.</dd>
<dt><strong><code>truncate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to truncate or clip inputs to web mercator limits.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.LngLat" href="#light_pipe.mercantile.LngLat">LngLat</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lnglat(x, y, truncate=False):
    &#34;&#34;&#34;Convert web mercator x, y to longitude and latitude

    Parameters
    ----------
    x, y : float
        web mercator coordinates in meters.
    truncate : bool, optional
        Whether to truncate or clip inputs to web mercator limits.

    Returns
    -------
    LngLat

    &#34;&#34;&#34;
    lng, lat = (
        x * R2D / RE,
        ((math.pi * 0.5) - 2.0 * math.atan(math.exp(-y / RE))) * R2D,
    )
    if truncate:
        lng, lat = truncate_lnglat(lng, lat)
    return LngLat(lng, lat)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.minmax"><code class="name flex">
<span>def <span class="ident">minmax</span></span>(<span>zoom)</span>
</code></dt>
<dd>
<div class="desc"><p>Minimum and maximum tile coordinates for a zoom level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>zoom</code></strong> :&ensp;<code>int</code></dt>
<dd>The web mercator zoom level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>minimum</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum tile coordinate (note: always 0).</dd>
<dt><strong><code>maximum</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum tile coordinate (2 ** zoom - 1).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidZoomError</code></dt>
<dd>If zoom level is not a positive integer.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; minmax(1)
(0, 1)
&gt;&gt;&gt; minmax(-1)
Traceback (most recent call last):
...
InvalidZoomError: zoom must be a positive integer
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache(maxsize=28)
def minmax(zoom):
    &#34;&#34;&#34;Minimum and maximum tile coordinates for a zoom level

    Parameters
    ----------
    zoom : int
        The web mercator zoom level.

    Returns
    -------
    minimum : int
        Minimum tile coordinate (note: always 0).
    maximum : int
        Maximum tile coordinate (2 ** zoom - 1).

    Raises
    ------
    InvalidZoomError
        If zoom level is not a positive integer.

    Examples
    --------
    &gt;&gt;&gt; minmax(1)
    (0, 1)
    &gt;&gt;&gt; minmax(-1)
    Traceback (most recent call last):
    ...
    InvalidZoomError: zoom must be a positive integer

    &#34;&#34;&#34;

    try:
        if int(zoom) != zoom or zoom &lt; 0:
            raise InvalidZoomError(&#34;zoom must be a positive integer&#34;)
    except ValueError:
        raise InvalidZoomError(&#34;zoom must be a positive integer&#34;)

    return (0, 2 ** zoom - 1)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.neighbors"><code class="name flex">
<span>def <span class="ident">neighbors</span></span>(<span>*tile, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The neighbors of a tile</p>
<p>The neighbors function makes no guarantees regarding neighbor tile
ordering.</p>
<p>The neighbors function returns up to eight neighboring tiles, where
tiles will be omitted when they are not valid e.g. Tile(-1, -1, z).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; neighbors(Tile(486, 332, 10))
[Tile(x=485, y=331, z=10), Tile(x=485, y=332, z=10), Tile(x=485, y=333, z=10), Tile(x=486, y=331, z=10), Tile(x=486, y=333, z=10), Tile(x=487, y=331, z=10), Tile(x=487, y=332, z=10), Tile(x=487, y=333, z=10)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbors(*tile, **kwargs):
    &#34;&#34;&#34;The neighbors of a tile

    The neighbors function makes no guarantees regarding neighbor tile
    ordering.

    The neighbors function returns up to eight neighboring tiles, where
    tiles will be omitted when they are not valid e.g. Tile(-1, -1, z).

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    list

    Examples
    --------
    &gt;&gt;&gt; neighbors(Tile(486, 332, 10))
    [Tile(x=485, y=331, z=10), Tile(x=485, y=332, z=10), Tile(x=485, y=333, z=10), Tile(x=486, y=331, z=10), Tile(x=486, y=333, z=10), Tile(x=487, y=331, z=10), Tile(x=487, y=332, z=10), Tile(x=487, y=333, z=10)]

    &#34;&#34;&#34;
    xtile, ytile, ztile = _parse_tile_arg(*tile)

    tiles = []

    lo, hi = minmax(ztile)

    for i in [-1, 0, 1]:
        for j in [-1, 0, 1]:
            if i == 0 and j == 0:
                continue
            elif xtile + i &lt; 0 or ytile + j &lt; 0:
                continue
            elif xtile + i &gt; hi or ytile + j &gt; hi:
                continue
            tiles.append(Tile(x=xtile + i, y=ytile + j, z=ztile))

    # Make sure to not generate invalid tiles for valid input
    # https://github.com/mapbox/mercantile/issues/122
    def valid(tile):
        validx = 0 &lt;= tile.x &lt;= 2 ** tile.z - 1
        validy = 0 &lt;= tile.y &lt;= 2 ** tile.z - 1
        validz = 0 &lt;= tile.z
        return validx and validy and validz

    tiles = [t for t in tiles if valid(t)]

    return tiles</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.parent"><code class="name flex">
<span>def <span class="ident">parent</span></span>(<span>*tile, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the parent of a tile</p>
<p>The parent is the tile of one zoom level lower that contains the
given "child" tile.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Determines the <em>zoom</em> level of the returned parent tile.
This defaults to one lower than the tile (the immediate parent).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; parent(Tile(0, 0, 2))
Tile(x=0, y=0, z=1)
&gt;&gt;&gt; parent(Tile(0, 0, 2), zoom=0)
Tile(x=0, y=0, z=0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parent(*tile, **kwargs):
    &#34;&#34;&#34;Get the parent of a tile

    The parent is the tile of one zoom level lower that contains the
    given &#34;child&#34; tile.

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.
    zoom : int, optional
        Determines the *zoom* level of the returned parent tile.
        This defaults to one lower than the tile (the immediate parent).

    Returns
    -------
    Tile

    Examples
    --------
    &gt;&gt;&gt; parent(Tile(0, 0, 2))
    Tile(x=0, y=0, z=1)
    &gt;&gt;&gt; parent(Tile(0, 0, 2), zoom=0)
    Tile(x=0, y=0, z=0)

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    x, y, z = tile

    if z == 0:
        return None

    # zoom is a keyword-only argument.
    zoom = kwargs.get(&#34;zoom&#34;, None)

    if zoom is not None and (z &lt;= zoom or zoom != int(zoom)):
        raise InvalidZoomError(
            &#34;zoom must be an integer and less than that of the input tile&#34;
        )

    if x != int(x) or y != int(y) or z != int(z):
        raise ParentTileError(&#34;the parent of a non-integer tile is undefined&#34;)

    target_zoom = z - 1 if zoom is None else zoom

    # Algorithm heavily inspired by https://github.com/mapbox/tilebelt.
    return_tile = tile
    while return_tile[2] &gt; target_zoom:
        xtile, ytile, ztile = return_tile
        if xtile % 2 == 0 and ytile % 2 == 0:
            return_tile = Tile(xtile // 2, ytile // 2, ztile - 1)
        elif xtile % 2 == 0:
            return_tile = Tile(xtile // 2, (ytile - 1) // 2, ztile - 1)
        elif not xtile % 2 == 0 and ytile % 2 == 0:
            return_tile = Tile((xtile - 1) // 2, ytile // 2, ztile - 1)
        else:
            return_tile = Tile((xtile - 1) // 2, (ytile - 1) // 2, ztile - 1)
    return return_tile</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.quadkey"><code class="name flex">
<span>def <span class="ident">quadkey</span></span>(<span>*tile)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the quadkey of a tile</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quadkey(*tile):
    &#34;&#34;&#34;Get the quadkey of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    str

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile
    qk = []
    for z in range(zoom, 0, -1):
        digit = 0
        mask = 1 &lt;&lt; (z - 1)
        if xtile &amp; mask:
            digit += 1
        if ytile &amp; mask:
            digit += 2
        qk.append(str(digit))
    return &#34;&#34;.join(qk)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.quadkey_to_tile"><code class="name flex">
<span>def <span class="ident">quadkey_to_tile</span></span>(<span>qk)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tile corresponding to a quadkey</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>qk</code></strong> :&ensp;<code>str</code></dt>
<dd>A quadkey string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quadkey_to_tile(qk):
    &#34;&#34;&#34;Get the tile corresponding to a quadkey

    Parameters
    ----------
    qk : str
        A quadkey string.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    if len(qk) == 0:
        return Tile(0, 0, 0)
    xtile, ytile = 0, 0
    for i, digit in enumerate(reversed(qk)):
        mask = 1 &lt;&lt; i
        if digit == &#34;1&#34;:
            xtile = xtile | mask
        elif digit == &#34;2&#34;:
            ytile = ytile | mask
        elif digit == &#34;3&#34;:
            xtile = xtile | mask
            ytile = ytile | mask
        elif digit != &#34;0&#34;:
            warnings.warn(
                &#34;QuadKeyError will not derive from ValueError in mercantile 2.0.&#34;,
                DeprecationWarning,
            )
            raise QuadKeyError(&#34;Unexpected quadkey digit: %r&#34;, digit)
    return Tile(xtile, ytile, i + 1)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>tiles)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduces the size of the tileset as much as possible by merging leaves into parents.</p>
<h2 id="parameters">Parameters</h2>
<p>tiles : Sequence of tiles to merge.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(tiles):
    &#34;&#34;&#34;Reduces the size of the tileset as much as possible by merging leaves into parents.

    Parameters
    ----------
    tiles : Sequence of tiles to merge.

    Returns
    -------
    list

    &#34;&#34;&#34;

    def merge(merge_set):
        &#34;&#34;&#34;Checks to see if there are 4 tiles in merge_set which can be merged.
        If there are, this merges them.
        This returns a list of tiles, as well as a boolean indicating if any were merged.
        By repeatedly applying merge, a tileset can be simplified.
        &#34;&#34;&#34;
        upwards_merge = {}
        for tile in merge_set:
            tile_parent = parent(tile)
            if tile_parent not in upwards_merge:
                upwards_merge[tile_parent] = set()
            upwards_merge[tile_parent] |= {tile}
        current_tileset = []
        changed = False
        for supertile, children in upwards_merge.items():
            if len(children) == 4:
                current_tileset += [supertile]
                changed = True
            else:
                current_tileset += list(children)
        return current_tileset, changed

    # Check to see if a tile and its parent both already exist.
    # Ensure that tiles are sorted by zoom so parents are encountered first.
    # If so, discard the child (it&#39;s covered in the parent)
    root_set = set()
    for tile in sorted(tiles, key=operator.itemgetter(2)):
        x, y, z = tile
        is_new_tile = True
        for supertile in (parent(tile, zoom=i) for i in range(z)):
            if supertile in root_set:
                is_new_tile = False
                continue
        if is_new_tile:
            root_set |= {tile}

    # Repeatedly run merge until no further simplification is possible.
    is_merging = True
    while is_merging:
        root_set, is_merging = merge(root_set)
    return root_set</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>lng, lat, zoom, truncate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tile containing a longitude and latitude</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lng</code></strong>, <strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>A longitude and latitude pair in decimal degrees.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>int</code></dt>
<dd>The web mercator zoom level.</dd>
<dt><strong><code>truncate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to truncate inputs to limits of web mercator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(lng, lat, zoom, truncate=False):
    &#34;&#34;&#34;Get the tile containing a longitude and latitude

    Parameters
    ----------
    lng, lat : float
        A longitude and latitude pair in decimal degrees.
    zoom : int
        The web mercator zoom level.
    truncate : bool, optional
        Whether or not to truncate inputs to limits of web mercator.

    Returns
    -------
    Tile

    &#34;&#34;&#34;
    x, y = _xy(lng, lat, truncate=truncate)
    Z2 = math.pow(2, zoom)

    if x &lt;= 0:
        xtile = 0
    elif x &gt;= 1:
        xtile = int(Z2 - 1)
    else:
        # To address loss of precision in round-tripping between tile
        # and lng/lat, points within EPSILON of the right side of a tile
        # are counted in the next tile over.
        xtile = int(math.floor((x + EPSILON) * Z2))

    if y &lt;= 0:
        ytile = 0
    elif y &gt;= 1:
        ytile = int(Z2 - 1)
    else:
        ytile = int(math.floor((y + EPSILON) * Z2))

    return Tile(xtile, ytile, zoom)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.tiles"><code class="name flex">
<span>def <span class="ident">tiles</span></span>(<span>west, south, east, north, zooms, truncate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tiles overlapped by a geographic bounding box</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>west</code></strong>, <strong><code>south</code></strong>, <strong><code>east</code></strong>, <strong><code>north</code></strong> :&ensp;<code>sequence</code> of <code>float</code></dt>
<dd>Bounding values in decimal degrees.</dd>
<dt><strong><code>zooms</code></strong> :&ensp;<code>int</code> or <code>sequence</code> of <code>int</code></dt>
<dd>One or more zoom levels.</dd>
<dt><strong><code>truncate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to truncate inputs to web mercator limits.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A small epsilon is used on the south and east parameters so that this
function yields exactly one tile when given the bounds of that same tile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiles(west, south, east, north, zooms, truncate=False):
    &#34;&#34;&#34;Get the tiles overlapped by a geographic bounding box

    Parameters
    ----------
    west, south, east, north : sequence of float
        Bounding values in decimal degrees.
    zooms : int or sequence of int
        One or more zoom levels.
    truncate : bool, optional
        Whether or not to truncate inputs to web mercator limits.

    Yields
    ------
    Tile

    Notes
    -----
    A small epsilon is used on the south and east parameters so that this
    function yields exactly one tile when given the bounds of that same tile.

    &#34;&#34;&#34;
    if truncate:
        west, south = truncate_lnglat(west, south)
        east, north = truncate_lnglat(east, north)
    if west &gt; east:
        bbox_west = (-180.0, south, east, north)
        bbox_east = (west, south, 180.0, north)
        bboxes = [bbox_west, bbox_east]
    else:
        bboxes = [(west, south, east, north)]

    for w, s, e, n in bboxes:
        # Clamp bounding values.
        w = max(-180.0, w)
        s = max(-85.051129, s)
        e = min(180.0, e)
        n = min(85.051129, n)

        if not isinstance(zooms, Sequence):
            zooms = [zooms]

        for z in zooms:
            ul_tile = tile(w, n, z)
            lr_tile = tile(e - LL_EPSILON, s + LL_EPSILON, z)

            for i in range(ul_tile.x, lr_tile.x + 1):
                for j in range(ul_tile.y, lr_tile.y + 1):
                    yield Tile(i, j, z)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.ul"><code class="name flex">
<span>def <span class="ident">ul</span></span>(<span>*tile)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the upper left longitude and latitude of a tile</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.LngLat" href="#light_pipe.mercantile.LngLat">LngLat</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ul(Tile(x=0, y=0, z=1))
LngLat(lng=-180.0, lat=85.0511287798066)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; mercantile.ul(1, 1, 1)
LngLat(lng=0.0, lat=0.0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ul(*tile):
    &#34;&#34;&#34;Returns the upper left longitude and latitude of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    LngLat

    Examples
    --------

    &gt;&gt;&gt; ul(Tile(x=0, y=0, z=1))
    LngLat(lng=-180.0, lat=85.0511287798066)

    &gt;&gt;&gt; mercantile.ul(1, 1, 1)
    LngLat(lng=0.0, lat=0.0)

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile
    Z2 = math.pow(2, zoom)
    lon_deg = xtile / Z2 * 360.0 - 180.0
    lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / Z2)))
    lat_deg = math.degrees(lat_rad)
    return LngLat(lon_deg, lat_deg)</code></pre>
</details>
</dd>
<dt id="light_pipe.mercantile.xy_bounds"><code class="name flex">
<span>def <span class="ident">xy_bounds</span></span>(<span>*tile)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the web mercator bounding box of a tile</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code> or <code>sequence</code> of <code>int</code></dt>
<dd>May be be either an instance of Tile or 3 ints, X, Y, Z.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="light_pipe.mercantile.Bbox" href="#light_pipe.mercantile.Bbox">Bbox</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Epsilon is subtracted from the right limit and added to the bottom
limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xy_bounds(*tile):
    &#34;&#34;&#34;Get the web mercator bounding box of a tile

    Parameters
    ----------
    tile : Tile or sequence of int
        May be be either an instance of Tile or 3 ints, X, Y, Z.

    Returns
    -------
    Bbox

    Notes
    -----
    Epsilon is subtracted from the right limit and added to the bottom
    limit.

    &#34;&#34;&#34;
    tile = _parse_tile_arg(*tile)
    xtile, ytile, zoom = tile

    tile_size = CE / math.pow(2, zoom)

    left = xtile * tile_size - CE / 2
    right = left + tile_size

    top = CE / 2 - ytile * tile_size
    bottom = top - tile_size

    return Bbox(left, bottom, right, top)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="light_pipe.mercantile.Bbox"><code class="flex name class">
<span>class <span class="ident">Bbox</span></span>
<span>(</span><span>left, bottom, right, top)</span>
</code></dt>
<dd>
<div class="desc"><p>Bbox(left, bottom, right, top)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="light_pipe.mercantile.Bbox.bottom"><code class="name">var <span class="ident">bottom</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="light_pipe.mercantile.Bbox.left"><code class="name">var <span class="ident">left</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="light_pipe.mercantile.Bbox.right"><code class="name">var <span class="ident">right</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="light_pipe.mercantile.Bbox.top"><code class="name">var <span class="ident">top</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
</dd>
<dt id="light_pipe.mercantile.LngLat"><code class="flex name class">
<span>class <span class="ident">LngLat</span></span>
<span>(</span><span>lng, lat)</span>
</code></dt>
<dd>
<div class="desc"><p>LngLat(lng, lat)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="light_pipe.mercantile.LngLat.lat"><code class="name">var <span class="ident">lat</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="light_pipe.mercantile.LngLat.lng"><code class="name">var <span class="ident">lng</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="light_pipe.mercantile.LngLatBbox"><code class="flex name class">
<span>class <span class="ident">LngLatBbox</span></span>
<span>(</span><span>west, south, east, north)</span>
</code></dt>
<dd>
<div class="desc"><p>LngLatBbox(west, south, east, north)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="light_pipe.mercantile.LngLatBbox.east"><code class="name">var <span class="ident">east</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="light_pipe.mercantile.LngLatBbox.north"><code class="name">var <span class="ident">north</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="light_pipe.mercantile.LngLatBbox.south"><code class="name">var <span class="ident">south</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="light_pipe.mercantile.LngLatBbox.west"><code class="name">var <span class="ident">west</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="light_pipe.mercantile.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>An XYZ web mercator tile</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong>, <strong><code>z</code></strong> :&ensp;<code>int</code></dt>
<dd>x and y indexes of the tile and zoom level z.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tile(namedtuple(&#34;Tile&#34;, [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;])):
    &#34;&#34;&#34;An XYZ web mercator tile

    Attributes
    ----------
    x, y, z : int
        x and y indexes of the tile and zoom level z.

    &#34;&#34;&#34;

    def __new__(cls, x, y, z):
        &#34;&#34;&#34;A new instance&#34;&#34;&#34;
        lo, hi = minmax(z)
        if not lo &lt;= x &lt;= hi or not lo &lt;= y &lt;= hi:
            warnings.warn(
                &#34;Mercantile 2.0 will require tile x and y to be within the range (0, 2 ** zoom)&#34;,
                FutureWarning,
            )
        return tuple.__new__(cls, [x, y, z])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="light_pipe.gridding.GridCell" href="gridding.html#light_pipe.gridding.GridCell">GridCell</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="light_pipe" href="index.html">light_pipe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="light_pipe.mercantile.bounding_tile" href="#light_pipe.mercantile.bounding_tile">bounding_tile</a></code></li>
<li><code><a title="light_pipe.mercantile.bounds" href="#light_pipe.mercantile.bounds">bounds</a></code></li>
<li><code><a title="light_pipe.mercantile.children" href="#light_pipe.mercantile.children">children</a></code></li>
<li><code><a title="light_pipe.mercantile.feature" href="#light_pipe.mercantile.feature">feature</a></code></li>
<li><code><a title="light_pipe.mercantile.lnglat" href="#light_pipe.mercantile.lnglat">lnglat</a></code></li>
<li><code><a title="light_pipe.mercantile.minmax" href="#light_pipe.mercantile.minmax">minmax</a></code></li>
<li><code><a title="light_pipe.mercantile.neighbors" href="#light_pipe.mercantile.neighbors">neighbors</a></code></li>
<li><code><a title="light_pipe.mercantile.parent" href="#light_pipe.mercantile.parent">parent</a></code></li>
<li><code><a title="light_pipe.mercantile.quadkey" href="#light_pipe.mercantile.quadkey">quadkey</a></code></li>
<li><code><a title="light_pipe.mercantile.quadkey_to_tile" href="#light_pipe.mercantile.quadkey_to_tile">quadkey_to_tile</a></code></li>
<li><code><a title="light_pipe.mercantile.simplify" href="#light_pipe.mercantile.simplify">simplify</a></code></li>
<li><code><a title="light_pipe.mercantile.tile" href="#light_pipe.mercantile.tile">tile</a></code></li>
<li><code><a title="light_pipe.mercantile.tiles" href="#light_pipe.mercantile.tiles">tiles</a></code></li>
<li><code><a title="light_pipe.mercantile.ul" href="#light_pipe.mercantile.ul">ul</a></code></li>
<li><code><a title="light_pipe.mercantile.xy_bounds" href="#light_pipe.mercantile.xy_bounds">xy_bounds</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="light_pipe.mercantile.Bbox" href="#light_pipe.mercantile.Bbox">Bbox</a></code></h4>
<ul class="">
<li><code><a title="light_pipe.mercantile.Bbox.bottom" href="#light_pipe.mercantile.Bbox.bottom">bottom</a></code></li>
<li><code><a title="light_pipe.mercantile.Bbox.left" href="#light_pipe.mercantile.Bbox.left">left</a></code></li>
<li><code><a title="light_pipe.mercantile.Bbox.right" href="#light_pipe.mercantile.Bbox.right">right</a></code></li>
<li><code><a title="light_pipe.mercantile.Bbox.top" href="#light_pipe.mercantile.Bbox.top">top</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="light_pipe.mercantile.LngLat" href="#light_pipe.mercantile.LngLat">LngLat</a></code></h4>
<ul class="">
<li><code><a title="light_pipe.mercantile.LngLat.lat" href="#light_pipe.mercantile.LngLat.lat">lat</a></code></li>
<li><code><a title="light_pipe.mercantile.LngLat.lng" href="#light_pipe.mercantile.LngLat.lng">lng</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="light_pipe.mercantile.LngLatBbox" href="#light_pipe.mercantile.LngLatBbox">LngLatBbox</a></code></h4>
<ul class="">
<li><code><a title="light_pipe.mercantile.LngLatBbox.east" href="#light_pipe.mercantile.LngLatBbox.east">east</a></code></li>
<li><code><a title="light_pipe.mercantile.LngLatBbox.north" href="#light_pipe.mercantile.LngLatBbox.north">north</a></code></li>
<li><code><a title="light_pipe.mercantile.LngLatBbox.south" href="#light_pipe.mercantile.LngLatBbox.south">south</a></code></li>
<li><code><a title="light_pipe.mercantile.LngLatBbox.west" href="#light_pipe.mercantile.LngLatBbox.west">west</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="light_pipe.mercantile.Tile" href="#light_pipe.mercantile.Tile">Tile</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>